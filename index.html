<!-- FX canvas for flying beans/nuts -->
<canvas id="fx"></canvas>

<!-- Hero background globe -->
<canvas id="hero3d"></canvas>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ======================
   2D Flying Beans/Nuts FX
   ====================== */
const fxCanvas = document.getElementById('fx');
const fxCtx = fxCanvas.getContext('2d');
const dpr = Math.min(window.devicePixelRatio || 1, 2);

function resizeFx() {
  fxCanvas.width = innerWidth * dpr;
  fxCanvas.height = innerHeight * dpr;
  fxCanvas.style.width = innerWidth + 'px';
  fxCanvas.style.height = innerHeight + 'px';
  fxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
addEventListener('resize', resizeFx);
resizeFx();

const SPRITES = {
  cashew: 'assets/cashew.png',
  cocoa:  'assets/cocoa.png',
  coffee: 'assets/coffee.png',
  rubber: 'assets/rubber.png'
};

const imgs = {};
const loadPromises = Object.entries(SPRITES).map(([k, src]) => new Promise(res => {
  const im = new Image();
  im.onload = () => { imgs[k] = im; res(); };
  im.onerror = () => { imgs[k] = null; res(); };
  im.src = src;
}));

const parts = [];
const BURST_COUNT = 60, GRAVITY = 0.08, AIR = 0.994, ROT_SPEED = 0.05;

function spawnBurst(kind, x, y) {
  const im = imgs[kind];
  for (let i=0;i<BURST_COUNT;i++){
    const ang = (Math.random()*Math.PI) - Math.PI/2;
    const speed = 3 + Math.random()*3.5;
    const vx = Math.cos(ang)*speed;
    const vy = Math.sin(ang)*speed - 1;
    const s = 20 + Math.random()*18;
    parts.push({ kind, im, x, y, vx, vy, rot: Math.random()*Math.PI*2,
      vr: (Math.random()-.5)*ROT_SPEED, s, life: 1 });
  }
}

function stepFx() {
  fxCtx.clearRect(0,0,innerWidth,innerHeight);
  for (let i=parts.length-1;i>=0;i--){
    const p = parts[i];
    p.vx *= AIR; p.vy = p.vy*AIR + GRAVITY;
    p.x += p.vx; p.y += p.vy;
    p.rot += p.vr;
    p.life -= 0.006;
    if (p.y > innerHeight + 80 || p.life <= 0) { parts.splice(i,1); continue; }

    fxCtx.save();
    fxCtx.translate(p.x, p.y);
    fxCtx.rotate(p.rot);
    fxCtx.globalAlpha = Math.max(0, Math.min(1, p.life));
    if (p.im) {
      fxCtx.drawImage(p.im, -p.s/2, -p.s/2, p.s, p.s);
    } else {
      const color = {cashew:'#E6C089', cocoa:'#6B3E2E', coffee:'#3C2A21', rubber:'#0A7F49'}[p.kind] || '#fff';
      fxCtx.fillStyle = color;
      fxCtx.beginPath(); fxCtx.arc(0,0,p.s*0.35,0,Math.PI*2); fxCtx.fill();
    }
    fxCtx.restore();
  }
  requestAnimationFrame(stepFx);
}

Promise.all(loadPromises).then(() => {
  const io = new IntersectionObserver(entries=>{
    for (const e of entries){
      if (e.isIntersecting && !e.target._burstOnce){
        e.target._burstOnce = true;
        const rect = e.target.getBoundingClientRect();
        spawnBurst(e.target.dataset.emit, innerWidth/2, rect.top + rect.height*0.45);
      }
    }
  }, { threshold: 0.5 });

  document.querySelectorAll('[data-emit]').forEach(el=>io.observe(el));
  stepFx();
});

/* ======================
   3D Spinning Globe
   ====================== */
const heroCanvas = document.getElementById('hero3d');
const renderer = new THREE.WebGLRenderer({ canvas: heroCanvas, antialias: true, alpha: true });
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100);
camera.position.set(0, 0, 6);

function resizeHero() {
  const w = heroCanvas.clientWidth = heroCanvas.parentElement.clientWidth;
  const h = heroCanvas.clientHeight = Math.max(400, heroCanvas.parentElement.clientHeight);
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resizeHero);
resizeHero();

const dots = 2000;
const positions = new Float32Array(dots * 3);
for (let i=0;i<dots;i++){
  const u = Math.random(), v = Math.random();
  const theta = 2 * Math.PI * u;
  const phi = Math.acos(2*v - 1);
  const r = 2.1;
  positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
  positions[i*3+1] = r * Math.cos(phi);
  positions[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
}
const geo = new THREE.BufferGeometry();
geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const mat = new THREE.PointsMaterial({ size: 0.02, color: 0x10B981 });
const globe = new THREE.Points(geo, mat);
scene.add(globe);

function animateGlobe(t){
  globe.rotation.y += 0.0018;
  globe.rotation.x = 0.15 * Math.sin(t*0.0003);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.render(scene, camera);
  requestAnimationFrame(animateGlobe);
}
animateGlobe();

/* Year in footer */
document.getElementById('year').textContent = new Date().getFullYear();
</script>
